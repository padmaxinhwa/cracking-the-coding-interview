# cracking-the-coding-interview

### 1. Big-O
- Purpose: Measures algorithm efficiency in terms of time and space as input size grows.
- Common Notations:
  - O(1) – Constant time
  - O(log n) – Logarithmic (e.g., binary search)
  - O(n) – Linear
  - O(n log n) – Log-linear (e.g., merge sort)
  - O(n²), O(2ⁿ), O(n!) – Quadratic to exponential
- Best, Average, Worst Cases: Analyze different scenarios for performance.
- Space Complexity: Tracks additional memory used by an algorithm.
- Amortized Analysis: Averages the cost of operations over a sequence (e.g., dynamic array resizing).
  
</br>

### 2. Data Structures
| ✅ | Topic | Summary |
|----|-------|---------|
|| Arrays and Strings | Fixed-size containers; focus on indexing, slicing, and in-place updates. |
|| Linked Lists | Nodes connected by pointers; types include singly and doubly linked lists. |
|| Stacks and Queues | LIFO and FIFO structures; often used in recursion, parsing, and scheduling. |
|| Hash Tables | Key-value mapping with average O(1) access; important for lookups and deduplication. |
|| Trees | Binary, BSTs, Tries, Heaps (Min/Max), Balanced Trees (AVL, Red-Black) |
|| Graphs | Directed/Undirected, adjacency list/matrix; key for network and relationship modeling |
|| Recursion | Solves problems by breaking them into subproblems; often tied to backtracking and divide-and-conquer. |

</br>

### 3. Algorithms
| ✅ | Topic | Summary |
|----|-------|---------|
|| Bit Manipulation | Solves problems efficiently using binary operations. |
|| Math and Number Theory | Includes prime tests, GCD/LCM, modular arithmetic, permutations/combinations. |
|| Object-Oriented Design | Understand classes, inheritance, polymorphism, encapsulation; apply design principles. |
|| Dynamic Programming | Breaks problems into overlapping subproblems using memoization or tabulation. |
|| Sorting | Merge sort, quicksort, heap sort, insertion sort—understand time/space trade-offs. |
|| Searching | Binary search, BFS, DFS; critical for trees and graphs. |
|| Testing | Unit testing, test cases, edge conditions. |
</br>

### 4. Knowledge-Based Questions
| ✅ | Topic | Summary |
|----|-------|---------|
|| System Design Basics | Covers scalability, caching, load balancing, database sharding, etc. |
|| Databases | Basic SQL knowledge, normalization, indexing. |
|| Concurrency | Threads, locks, deadlock avoidance, race conditions. |
|| Testing | Unit testing, test cases, edge conditions. |
|| Scalability Concepts | Horizontal/vertical scaling, statelessness, latency reduction. |
|| Memory and Performance | Garbage collection, memory leaks, profiling basics. |

</br>

### 5. Advanced Topics
| ✅ | Topic | Summary |
|----|-------|---------|
|| 유용한 수학 |  |
|| 위상정렬 |  |
|| 다익스트라 알고리즘 |  |
|| 해시테이블에서 충돌을 해결하는 방법 |  |
|| 선형 탐사법을 이용한 개방 주소법 |  |
|| Rabin-Karp 부분 문자열 탐색 알고리즘 |  |
|| AVL 트리 |  |
|| 레드-블랙 트리 |  |
|| MapReduce |  |
|| Design Patterns | Common solutions to recurring design problems (Singleton, Factory, Observer, etc.) |
|| Distributed Systems | CAP theorem, consistency models, message queues, eventual consistency. |
|| Machine Learning Basics (optional) | Sometimes discussed in tech interviews. |
|| Advanced Graph Algorithms | Dijkstra, A*, Bellman-Ford, Union-Find, Topological Sort. |
|| Trie and Suffix Trees | Useful for string-related problems. |
|| Segment Trees and Fenwick Trees | Advanced structures for range queries and updates. |
|| Memory Optimization | Bit arrays, compression techniques, cache locality. |
